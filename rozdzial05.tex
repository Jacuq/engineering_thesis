\chapter{Implementacja aplikacji} 

\section{Implementacja Backendu}



\section{Implementacja Frontendu}

Schemat projektu aplikacji frontendowej jest typowy dla aplikacji implementowanych w Angularze. Program podzielony jest na fragmenty zwane komponentami oraz serwisami. Ka¿dy komponent oraz ka¿dy serwis jest przechowywany w osobnym folderze. Katalog assests zawiera zasoby wykorzystywane w aplikacji, takie jak dŸwiêki czy obrazki. Oprócz komponentów stworzonych przez u¿ytkownika wykorzystywane s¹ równie¿ pliki wygenerowane za pomoc¹ Angular CLI znajduj¹ce siê w katalogu g³ównym: 
\begin{description}
 \item [app-routing.module.ts] - modu³ pozwalaj¹cy na zarz¹dzanie routingiem wewn¹trz projektu
 \item [app.module.ts] -  g³ówny modu³ aplikacji opisuj¹cy elementy importowane przez aplikacjê oraz deklarowane w niej komponenty i serwisy
 \item [app.*] - pozosta³e pliki kompenentu g³ównego
 \item [environment.prod.ts] - plik zawieraj¹ce zmienne œrodowiskowe dla œrodowiska produkcyjnego
 \item [environment.ts] - zmienne œrodowiskowe do wykorzystania podczas tworzenia i testowania aplikacji
\end{description}

\begin{figure}[H]
 \centering
 \includegraphics[width=0.4\textwidth]{rys05/schemat_FE.png}
 \caption{Schemat projektu aplikacji Frontendowej}
 \label{fig:schemat_FE}
\end{figure}

Ka¿dy komponent sk³ada siê z 4 plików:
\begin{description}
 \item [component-name.css] - plik opisuj¹cy style wykorzystane w obrêbie tego komponentu,
 \item [component-name.html] - plik opisuj¹cy rozk³ad elementów w danym komponencie. Angular pozwala na wykorzystywanie tam selektorów innych komponentów oraz dodatkowych dyrektyw, takich jak np. ngIf czy ngFor,
 \item [component-name.ts] - plik zawieraj¹cy konstruktor komponentu oraz skrypty napisane przez u¿ytkownika dla danego komponentu,
 \item [component-name.spec.ts] - plik zawieraj¹cy testy jednostkowe komponentu.
\end{description}
Serwisy natomiast sk³adaj¹ siê domyœlnie z 2 plików: service-name.ts oraz service-name.spec.ts. Pe³ni¹ one takie same role jak w wypadku komponentów - pierwszy z nich zawiera klasê serwisu, natomiast drugi jej testy jednostkowe.

\begin{figure}[H]
 \centering
 \includegraphics[width=0.6\textwidth]{rys05/schemat_FE2.png}
 \caption{Katalogi audio-player oraz guitar-page pokazuj¹ schemat plików odpowiednio serwisu i komponentu}
 \label{fig:schemat_FE2}
\end{figure}

\subsection{Strona g³ówna}

Na stronie g³ownej wyœwietlony jest panel z krótkim tekstem o aplikacji oraz jej autorze. \\
Na górze strony widoczny jest pasek nawigacji, który pozwala na przejœcie do wszystkich funkcjonalnoœci aplikacji. \\   
To na tê stronê przekierowywany jest u¿ytkownik jeœli próbuje dostaæ sie na nieistniej¹c¹ podstronê. 

\begin{figure}[h]
 \centering
 \includegraphics[width=0.6\textwidth]{rys05/homepage.png}
 \caption{Katalogi audio-player oraz guitar-page pokazuj¹ schemat plików odpowiednio serwisu i komponentu}
 \label{fig:homepage}
\end{figure}


\subsection{Nawigacja}

Do nawigacji podczas korzystania z aplikacji s³u¿y pasek nawigacji umieszczony na górze strony. Ka¿dy z guzików jest odnoœnikiem do odpowiednich podstron. Próba przejœcia na podstrony, które nie s¹ wymienione na pasku nawigacji skutkuje przekierowaniem stronê g³ówn¹. Implementacja nawigacji opiera siê na wykorzystaniu modu³u routing zawaratego w Angularze. W pliku app-routing.module.ts zdefiniowano wszystkie œcie¿ki obs³ugiwane przez aplikacjê. Mo¿na je zobaczyæ na listingu \ref{lst:routing}. szczególnie warto zwróciæ uwagê na ostatni wpis w tablicy. Wpis path: '**' to tzw. dzika karta (ang. wildcard route) - œcie¿ka, która jest wykorzystywana, kiedy u¿ytkownik próbuje dostaæ siê na dowoln¹ podstronê, która nie zosta³a opisana w tablicy przed wyst¹pieniem tego wpisu. Ze wzglêdu na sposób dzia³ania routingu, wa¿ne, aby dzika karta by³a na koñcu tablicy: podczas szukania œcie¿ki porównywana jest podana œcie¿ka i kolejne wartoœci pola ``path'' w tablicy Routes. Porównanie dowolnej œcie¿ki z symbolem '**' zawsze zwraca wartoœæ prawda, wiêc umieszczenie tego symbolu jako wczeœniejszego wpisu, zablokowa³oby dostêp do œcie¿ek zadeklarowanych póŸniej. 
\begin{lstlisting}[caption={Œcie¿ki zdefiniowane w aplikacji}, label={lst:routing}, language=JavaScript]
 const routes: Routes = [
  {path: 'test', component: VirtualGuitarComponent, pathMatch: 'full'},
  {path: 'api', component: ApiRequestSelectorComponent, pathMatch: 'full'},
  {path: 'bass', component: GuitarPageComponent, pathMatch: 'full'},
  {path: 'acoustic', component: GuitarPageComponent, pathMatch: 'full'},
  {path: 'earTraining', component: EarTrainingComponent, pathMatch: 'full'},
  {path: 'practice', component: TheoryQuizComponent, pathMatch: 'full'},
  {path: '**', component: HomepageComponent}
];
\end{lstlisting}


\subsection{Komunikacja z API}

W celu komunikacji z API zaimplementowano serwis TheoryApiService oraz modele danych odpowiadaj¹ce tym z API, czyli klasy: Chord, Interval oraz Scale. Klasê Scale przedstawiono na listingu \ref{lst:TheoryModel}. Serwis s³u¿y do wysy³ania zapytañ HTTP na zadany adres i rzutuje otrzymane dane na rz¹dany typ. \\

\begin{lstlisting}[caption={Klasa Scale wykorzystywana do zapytañ i przechowywania danych o skalach}, label={lst:TheoryModel}, language=JavaScript]
 export class Scale {
    constructor(
        public name: string,
        public notes: string[],
    ) { }
}
\end{lstlisting}


TheoryApiService wykorzystuje zmienn¹ œrodowiskow¹ API\_URL pod któr¹ przechowywany jest adres API, dziêki czemu mo¿na modyfikowaæ adres API bez ingerencji w kod. Zastosowanie zmiennych œrodowiskowych jest szczególnie istotne kiedy dochodzi do dystrybucji aplikacji - adresy API mog¹ siê zmieniaæ i nie powinno to powodowaæ potrzeby aktualizacji aplikacji. Przyk³adowe zapytanie do API z wykorzystaniem zmiennej œrodowiskowej mo¿na zobaczyæ na listingu \ref{lst:TheoryApiService}. 

\begin{lstlisting}[caption={Metoda klasy TheoryApiService wysy³aj¹ca zapytanie o dŸwiêki akordu do API}, label={lst:TheoryApiService}, language=JavaScript]
 getChord(rootNote: string, name: string): Observable<Chord[]> {
        return this.http
        .get<Chord[]>(`${API_URL}/chord/${rootNote}/${name}`).pipe(
            tap(_ => console.log('fetched')),
            catchError(TheoryApiService._handleError)
        );
    }
\end{lstlisting}





Takie rozwi¹zanie pozwala na wykorzystywanie tego samego serwisu w wielu komponentach poprzez wstrzykiwanie zale¿noœci. W Angularze proces ten odbywa siê poprzez oznaczenie klasy serwisu dekoratorem Injectable oraz zadeklarowanie odpowiedniej zale¿noœci w konstruktorze komponentu (serwis przekazuje siê jako argument konstruktora i przypisuje do odpowiedniego pola w klasie kompenentu). Przyk³ad wstrzykiwania zale¿noœci mo¿na zobaczyæ na listingu \ref{lst:DependencyInjection}, do kompenentu s¹ tam wstrzykiwane dwie zale¿noœci: TheoryApiService oraz ActivatedRoute. 

\begin{lstlisting}[caption={Wstrzykiwanie zale¿noœci do komponentu GuitarPageComponent}, label={lst:DependencyInjection}, language=JavaScript]
 constructor(api: TheoryApiService, route: ActivatedRoute) { 
    this.theoryApi = api;
    this.route = route;
  }
\end{lstlisting}


\subsection{Podstrony z wirtualnymi instrumentami}
Podstrony z wirtualnymi instrumentami zosta³y stworzone poprzez po³¹czenie ze sob¹ mniejszych komponentów: selektora zapytañ, suwaka reguluj¹cego g³oœnoœæ oraz wirtualnego instrumentu. \\
\begin{figure}[h]
\centering
\includegraphics[width=0.8\textwidth]{rys05/no_request_no_hover.png}
\caption{Widok strony z gitar¹ basow¹ przed wykonaniem zapytania}
\label{fig:noReqNoHov}
\end{figure}


W aplikacji zosta³y zaimplementowane dwa instrumenty: gitarê akustyczn¹ oraz gitarê basow¹. Bazuj¹ one na tym samym komponencie, poniewa¿ na poziomie abstrakcji, na którym operowano podczas implementacji róznica miêdzy nimi to tylko liczba strun.  \\

Na ka¿dym z instrumentów po wybraniu zapytania podœwietlaj¹ siê odpowiednie dŸwiêki. Wynik przyk³adowego zapytania mo¿na zobaczyæ na rysunkach \ref{fig:reqNoHov}, \ref{fig:reqHov} i \ref{fig:reqAcoustic}. Wybrano zapytanie o skalê F Natural Major (F-dur). W sk³ad tej skali wchodz¹ dŸwiêki: F,G,A,A\#,C,D,E i te dŸwiêki s¹ zaznaczone kolorem czerwonym. \\
Jeœli u¿ytkownika interesuj¹ tylko dŸwiêki nale¿¹ce do wybranego zapytania, mo¿e on wy³¹czyæ wyœwietlanie pozosta³ych dŸwiêków przyciskaj¹c guzik ``show notes on hover'' - powoduje on ukrycie wszystkich dŸwiêków, które nie nale¿¹ do aktualnego zapytania i wyœwietlanie ich dopiero po najechaniu kursorem. \\

Klikniêcie na dowolny dŸwiêk powoduje odtworzenie jego próbki dŸwiêkowej. Za odtwarzanie dŸwiêków odpowiada serwis AudioPlayerService. Klasa ta definiuje œcie¿ki do próbek dŸwiêkowych danego instrumentu oraz posiada metodê pozwalaj¹c¹ na odtworzenie dŸwiêku po stronie klienta. 
\begin{lstlisting}[caption={Metoda odtwrzaj¹ca zadany dŸwiêk}, label={lst:playNote}, language=JavaScript]
 playNote(guitar_string:string, note:string, volume:number)
  {
    let audio = new Audio();
    //change format, file path can't contain '#' symbol
    if(note.length > 1 && note[1] == '#')
      note = note[0] + 's' + note.substring(2);
    audio.src = this.samplesDirectory + guitar_string + "/" + note + ".wav";
    audio.volume = volume
    audio.load();
    audio.play();
  }
\end{lstlisting}

Nagrania próbowano pozyskaæ z serwisów oferuj¹cych darmowe próbki oraz gotowych paczek, jednak nie uda³o siê znaleŸæ pe³nego, darmowego zestawu, który mo¿na by³oby wykorzystaæ w ramach aplikacji, wiêc zdecydowano siê na w³asnorêczne nagranie gitar w domowych warunkach. \\

\begin{figure}[h]   
\centering
\includegraphics[width=0.8\textwidth]{rys05/request_no_hover.png}
\caption{Widok strony z gitar¹ basow¹ po wykonanu zapytania}
\label{fig:reqNoHov}
\end{figure}

\begin{figure}[h]
\centering
\includegraphics[width=0.8\textwidth]{rys05/request_hover.png}
\caption{Widok strony z gitar¹ basow¹ po wykonaniu zapytania i prze³¹czeniu opcji hover}
\label{fig:reqHov}
\end{figure}

\begin{figure}[h]
\centering
\includegraphics[width=0.8\textwidth]{rys05/request_acoustic.png}
\caption{Widok strony z gitar¹ akustyczn¹ po wykonaniu zapytania}
\label{fig:reqAcoustic}
\end{figure}



\subsection{Trening s³uchu}

Podstrona s³u¿¹ca do treningu ucha muzycznego to kolejny komponent wykorzystuj¹cy AudioService poprzez wstrzykiwanie zale¿noœci. \\ 
Æwiczenie polega na rozpoznawaniu odtwarzanego dŸwiêku ze s³uchu. U¿ytkownik mo¿e u¿yæ przycisku ``Play sound'' aby odtworzyæ próbkê. Guzik jest wieloktrotengo u¿ytku. Po ods³uchaniu próbki, u¿ytkownik wybiera jeden z dŸwiêków z listy rozwijanej i zatwierdza wybór guzikiem ``Check answer''. W wypadku udzielenia poprawnej odpowiedzi zwiêksza siê liczba punktów, a w wypadku z³ej, liczba punktów jest ustawiana na 0. W obu wypadkach losowany jest nowy dŸwiêk, aby u¿ytkownik móg³ kontynuowaæ æwiczenie. \\
Na stronie jest równie¿ guzik reset, który zeruje wynik u¿ytkownika oraz losuje now¹ próbkê dŸwiêkow¹.


\begin{figure}[h]
 \centering
 \includegraphics[width=0.8\textwidth]{rys05/ear_training1.png}
 \caption{Pocz¹tkowy stan komponentu treningu s³uchu}
\label{fig:ear1}
\end{figure}

\begin{figure}[h]
 \centering
 \includegraphics[width=0.8\textwidth]{rys05/ear_training2.png}
 \caption{Stan komponentu treningu s³uchu po udzieleniu poprawnej odpowiedzi}
\label{fig:ear2}
\end{figure}


\subsection{Quiz}

Ten komponent jest zale¿ny od serwisu TheoryApiService. Podstrona z quizem z wiedzy dotycz¹cej akordów dzia³a podobnie do podstrony z treningiem s³uchu - najpierw u¿ytkownikowi zadawane jest pytanie, póŸniej wybiera on odpowiedŸ za pomoc¹ list rozwijanych i zatwierdza wybór guzikiem.  Po udzieleniu dobrej odpowiedzi jego wynik jest inkrementowany, a po niepoprawnej wynik jest zerowany. W obu wypadkach po udzieleniu odpowiedzi losowane jest nowe pytanie. Na stronie jest równie¿ guzik reset losuj¹cy nowe pytanie i zeruj¹cy wynik. \\
Zaimplementowane pytania polegaj¹ na rozpoznawaniu losowo wybieranych akordów po buduj¹cych je dŸwiêkach, ³atwo jednak rozwin¹æ go dodatkowe pytania dodaj¹c do list np. interwa³y.

\begin{lstlisting}[caption={Metoda generuj¹ca losowy akord}, label={lst:rngChord}, language=JavaScript]
 getChord()
  {

    let chordName = this.chordsNames[Math.floor(Math.random() * this.chordsNames.length)];
    let noteName  = this.notes[Math.floor(Math.random() * this.notes.length)];
    this.currentChord = chordName;
    this.currentNote = noteName;
    this.notesInChord = null;
    
    if (noteName.includes('#') ){
      noteName = noteName[0] + 'S';
    }
    let split: number = chordName.indexOf(' ');
    chordName = chordName.toLowerCase();
    chordName = chordName.substr(0, split) + '_' + chordName.substr(split+1);
    console.log(noteName, chordName)
    this.theoryApi.getChord(noteName, chordName).subscribe(data => {
      this.notesInChord = data;
    });
    
  }
\end{lstlisting}


\begin{figure}[h]
 \centering
 \includegraphics[width=0.8\textwidth]{rys05/quiz1.png}
 \caption{Pocz¹tkowy stan komponentu treningu s³uchu}
\label{fig:quiz1}
\end{figure}

\begin{figure}[h]
 \centering
 \includegraphics[width=0.8\textwidth]{rys05/quiz2.png}
 \caption{Stan komponentu treningu s³uchu po udzieleniu poprawnej odpowiedzi}
\label{fig:quiz2}
\end{figure}
