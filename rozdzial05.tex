\chapter{Implementacja aplikacji} 

\section{Implementacja Backendu}

Schemat projektu aplikacji backendowej przedstawiono na rysunku \ref{fig:schemat_BE}. Najwa¿niejszymi modu³ami s¹ pliki notes\_calc.py i theory\_api.py - odpowiadaj¹ one kolejno za obliczanie dŸwiêków w danych akordach, skalach czy interwa³ach oraz za tworzenie endpointów aplikacji. \\
Pliki chords.py, scales.py, intervals.py to pliki pomocnicze zawieraj¹ce definicje wzorców wykorzystowanych przez notes\_calc oraz listy wszystkich dostêpnych obiektów. \\
Pliki testów jednostkowych znajduj¹ siê w katalogu tests. 

\begin{figure}[H]
 \centering
 \includegraphics[width=0.4\textwidth]{rys05/schemat_BE.png}
 \caption{Schemat projektu aplikacji Frontendowej}
 \label{fig:schemat_BE}
\end{figure}

\subsection{Endpointy}

Endpointy deklarowane s¹ w sposób typowy dla frameworka Flask, czyli poprzez dekoratory funkcji opisuj¹ce œcie¿kê oraz dostêpne metody. Wszystkie endpointy zawarte w API zwracaj¹ obiekty JSON. 
Elementy œcie¿ki zapisane jako ``<name>'' to parametry œcie¿ki - zmienne, które s¹ poŸniej wykorzystywane w celu uszczegó³awiania zapytania. W g³ównym endpoincie API, przedstawionym na listnigu \ref{lst:Endpoint}, œcie¿ka opisana jest trzema parametrami, z których ka¿dy coraz bardziej zawê¿a zapyanie. Pocz¹tkowo obszar poszukiwania odpowiedzi jest okreœlany przez obj\_type - wybierana jest jedna 3 kategorii: skala, interwa³ lub akord. Nastêpnie podawana jest nuta g³ówna, a na koñcu nazwa obiektu. 

\begin{lstlisting}[caption={G³ówny endpoint stworzonego API}, label={lst:Endpoint}, language=Python]
 @theory_api.route('/<obj_type>/<root>/<name>', methods=['GET'])
def get_obj(root: str, name: str, obj_type: str) -> flask.Response:
    # get root from link, check if it's a legal note and cast to proper format
    print(f"root:{root}; name:{name}; obj_type:{obj_type}")
    root = cast_root(root)
    if root is None:
        return wrong_request("Incorrect root note")

    # try to find proper object, if there's no matching obj type - wrong request
    obj = None
    if obj_type == 'chord':
        obj = find_chord(root, name)
    elif obj_type == 'scale':
        obj = find_scale(root, name)
    elif obj_type == 'interval':
        obj = find_interval(root, name)
    else:
        return wrong_request("Incorrect obj_type in request")

    # obj type was correct, but interval wasn't found - wrong interval in request
    if obj is None:
        return wrong_request(f"Incorrect {obj_type} name")

    # all went smooth - return requested sound
    return jsonify(obj)
\end{lstlisting}


\subsection{Obliczanie dŸwiêków}

W celu obliczania dŸwiêków wykorzystano nastêpuj¹ce za³o¿enia:
\begin{itemize}
 \item ka¿dy dŸwiêk ma wartoœæ liczbow¹ od 0 do 11, zaczynaj¹c od dŸwiêku 'E',
 \item przez dŸwiêk rozumie siê równie¿ pó³tony,
 \item oktawy to wielkoœci okresowe (po ostatnim dŸwiêku w oktawie nastêpuje powrót do pierwszego),
 \item odleg³oœæ miêdzy pó³tonami wynosi 1 jednostkê.
\end{itemize}

Korzystaj¹c z takich za³o¿eñ wszystkie akordy, skale i interwa³y opisano za pomoc¹ odleg³oœci od poprzeniego dŸwiêku. Pierwszy dŸwiêk to zawsze nuta g³ówna, drugi dŸwiêk opisany jest odleg³oœci¹ od nuty g³ównej, trzeci dŸwiêk odleg³oœci¹ od drugiego dŸwiêku itd. \\

\begin{lstlisting}[caption={Wzorce opisuj¹ce przyk³adowe akordy}, label={lst:chordsPatterns}, language=Python]
 seventh_pattern = (4, 3, 3)
 minor_seventh_pattern = (3, 4, 3)
 major_seventh_pattern = (4, 3, 4)
 diminished_seventh_pattern = (3, 3, 3)
\end{lstlisting}


Na podstawie opisanych za³o¿eñ oraz wzorców stworzono funkcje obliczaj¹ce dŸwiêki zawarte w skalach, akordach i interwa³ach na podstawie ich nazwy oraz nuty g³ównej. Na listingach \ref{lst:calcScale}, \ref{lst:calcChord} przedstawiono funkcje dla akordów oraz skal.

\begin{lstlisting}[caption={Funkcja obliczaj¹ca dŸwiêki w skali}, label={lst:calcScale}, language=Python]
 def find_scale(root: str, scale_name: str) -> list:
    curr_sound = notes_mapping.get(root)
    pattern = scales_patterns.get(scale_name)
    if pattern is None:
        return None
    scale = [root]
    for step in pattern:
        curr_sound += step
        sound = sound_from_val(curr_sound % 12)
        scale.append(sound)
    return scale
\end{lstlisting}

\begin{lstlisting}[caption={Funkcja obliczaj¹ca dŸwiêki w akordzie}, label={lst:calcChord}, language=Python]
 def find_chord(root: str, chord_name: str) -> list:
    curr_sound = notes_mapping.get(root)
    pattern = chords_patterns.get(chord_name)
    if pattern is None:
        return None
    chord = [root]
    for step in pattern:
        curr_sound += step
        sound = sound_from_val(curr_sound % 12)
        chord.append(sound)
    return chord
\end{lstlisting}

\section{Obserwacje i uwagi}
Po zaimplementowaniu ca³oœci aplikacji, zauwa¿ono, ¿e obliczenia s¹ na tyle niewymagaj¹ce, ¿e mog³yby byæ wykonywane po stronie frontendu zamiast dodatkowego API. Warto jednak zauwa¿yæ, ¿e API mo¿na ³atwo rozwin¹æ o dodatkowe funkcjonalnoœci, takie jak np. po³¹czenie z baz¹ danych, co mog³oby okazaæ siê przydatne w wypadku rozwoju aplikacji o konta u¿ytkowników. 

\section{Implementacja Frontendu}

Schemat projektu aplikacji frontendowej jest typowy dla aplikacji implementowanych w Angularze. Program podzielony jest na fragmenty zwane komponentami oraz serwisami. Ka¿dy komponent oraz ka¿dy serwis jest przechowywany w osobnym folderze. Katalog assests zawiera zasoby wykorzystywane w aplikacji, takie jak dŸwiêki czy obrazki. Oprócz komponentów stworzonych przez u¿ytkownika wykorzystywane s¹ równie¿ pliki wygenerowane za pomoc¹ Angular CLI znajduj¹ce siê w katalogu g³ównym: 
\begin{description}
 \item [app-routing.module.ts] - modu³ pozwalaj¹cy na zarz¹dzanie routingiem wewn¹trz projektu
 \item [app.module.ts] -  g³ówny modu³ aplikacji opisuj¹cy elementy importowane przez aplikacjê oraz deklarowane w niej komponenty i serwisy
 \item [app.*] - pozosta³e pliki kompenentu g³ównego
 \item [environment.prod.ts] - plik zawieraj¹ce zmienne œrodowiskowe dla œrodowiska produkcyjnego
 \item [environment.ts] - zmienne œrodowiskowe do wykorzystania podczas tworzenia i testowania aplikacji
\end{description}

\begin{figure}[H]
 \centering
 \includegraphics[width=0.4\textwidth]{rys05/schemat_FE.png}
 \caption{Schemat projektu aplikacji Frontendowej}
 \label{fig:schemat_FE}
\end{figure}

Ka¿dy komponent sk³ada siê z 4 plików:
\begin{description}
 \item [component-name.css] - plik opisuj¹cy style wykorzystane w obrêbie tego komponentu,
 \item [component-name.html] - plik opisuj¹cy rozk³ad elementów w danym komponencie. Angular pozwala na wykorzystywanie tam selektorów innych komponentów oraz dodatkowych dyrektyw, takich jak np. ngIf czy ngFor,
 \item [component-name.ts] - plik zawieraj¹cy konstruktor komponentu oraz skrypty napisane przez u¿ytkownika dla danego komponentu,
 \item [component-name.spec.ts] - plik zawieraj¹cy testy jednostkowe komponentu.
\end{description}
Serwisy natomiast sk³adaj¹ siê domyœlnie z 2 plików: service-name.ts oraz service-name.spec.ts. Pe³ni¹ one takie same role jak w wypadku komponentów - pierwszy z nich zawiera klasê serwisu, natomiast drugi jej testy jednostkowe.

\begin{figure}[H]
 \centering
 \includegraphics[width=0.6\textwidth]{rys05/schemat_FE2.png}
 \caption{Katalogi audio-player oraz guitar-page pokazuj¹ schemat plików odpowiednio serwisu i komponentu}
 \label{fig:schemat_FE2}
\end{figure}

\subsection{Strona g³ówna}

Na stronie g³ownej wyœwietlony jest panel z krótkim tekstem o aplikacji oraz jej autorze. \\
Na górze strony widoczny jest pasek nawigacji, który pozwala na przejœcie do wszystkich funkcjonalnoœci aplikacji. \\   
To na tê stronê przekierowywany jest u¿ytkownik jeœli próbuje dostaæ sie na nieistniej¹c¹ podstronê. 

\begin{figure}[h]
 \centering
 \includegraphics[width=0.6\textwidth]{rys05/homepage.png}
 \caption{Katalogi audio-player oraz guitar-page pokazuj¹ schemat plików odpowiednio serwisu i komponentu}
 \label{fig:homepage}
\end{figure}


\subsection{Nawigacja}

Do nawigacji podczas korzystania z aplikacji s³u¿y pasek nawigacji umieszczony na górze strony. Ka¿dy z guzików jest odnoœnikiem do odpowiednich podstron. Próba przejœcia na podstrony, które nie s¹ wymienione na pasku nawigacji skutkuje przekierowaniem stronê g³ówn¹. Implementacja nawigacji opiera siê na wykorzystaniu modu³u routing zawaratego w Angularze. W pliku app-routing.module.ts zdefiniowano wszystkie œcie¿ki obs³ugiwane przez aplikacjê. Mo¿na je zobaczyæ na listingu \ref{lst:routing}. szczególnie warto zwróciæ uwagê na ostatni wpis w tablicy. Wpis path: '**' to tzw. dzika karta (ang. wildcard route) - œcie¿ka, która jest wykorzystywana, kiedy u¿ytkownik próbuje dostaæ siê na dowoln¹ podstronê, która nie zosta³a opisana w tablicy przed wyst¹pieniem tego wpisu. Ze wzglêdu na sposób dzia³ania routingu, wa¿ne, aby dzika karta by³a na koñcu tablicy: podczas szukania œcie¿ki porównywana jest podana œcie¿ka i kolejne wartoœci pola ``path'' w tablicy Routes. Porównanie dowolnej œcie¿ki z symbolem '**' zawsze zwraca wartoœæ prawda, wiêc umieszczenie tego symbolu jako wczeœniejszego wpisu, zablokowa³oby dostêp do œcie¿ek zadeklarowanych póŸniej. 
\begin{lstlisting}[caption={Œcie¿ki zdefiniowane w aplikacji}, label={lst:routing}, language=JavaScript]
 const routes: Routes = [
  {path: 'test', component: VirtualGuitarComponent, pathMatch: 'full'},
  {path: 'api', component: ApiRequestSelectorComponent, pathMatch: 'full'},
  {path: 'bass', component: GuitarPageComponent, pathMatch: 'full'},
  {path: 'acoustic', component: GuitarPageComponent, pathMatch: 'full'},
  {path: 'earTraining', component: EarTrainingComponent, pathMatch: 'full'},
  {path: 'practice', component: TheoryQuizComponent, pathMatch: 'full'},
  {path: '**', component: HomepageComponent}
];
\end{lstlisting}


\subsection{Komunikacja z API}

W celu komunikacji z API zaimplementowano serwis TheoryApiService oraz modele danych odpowiadaj¹ce tym z API, czyli klasy: Chord, Interval oraz Scale. Klasê Scale przedstawiono na listingu \ref{lst:TheoryModel}. Serwis s³u¿y do wysy³ania zapytañ HTTP na zadany adres i rzutuje otrzymane dane na rz¹dany typ. \\

\begin{lstlisting}[caption={Klasa Scale wykorzystywana do zapytañ i przechowywania danych o skalach}, label={lst:TheoryModel}, language=JavaScript]
 export class Scale {
    constructor(
        public name: string,
        public notes: string[],
    ) { }
}
\end{lstlisting}


TheoryApiService wykorzystuje zmienn¹ œrodowiskow¹ API\_URL pod któr¹ przechowywany jest adres API, dziêki czemu mo¿na modyfikowaæ adres API bez ingerencji w kod. Zastosowanie zmiennych œrodowiskowych jest szczególnie istotne kiedy dochodzi do dystrybucji aplikacji - adresy API mog¹ siê zmieniaæ i nie powinno to powodowaæ potrzeby aktualizacji aplikacji. Przyk³adowe zapytanie do API z wykorzystaniem zmiennej œrodowiskowej mo¿na zobaczyæ na listingu \ref{lst:TheoryApiService}. 

\begin{lstlisting}[caption={Metoda klasy TheoryApiService wysy³aj¹ca zapytanie o dŸwiêki akordu do API}, label={lst:TheoryApiService}, language=JavaScript]
 getChord(rootNote: string, name: string): Observable<Chord[]> {
        return this.http
        .get<Chord[]>(`${API_URL}/chord/${rootNote}/${name}`).pipe(
            tap(_ => console.log('fetched')),
            catchError(TheoryApiService._handleError)
        );
    }
\end{lstlisting}





Takie rozwi¹zanie pozwala na wykorzystywanie tego samego serwisu w wielu komponentach poprzez wstrzykiwanie zale¿noœci. W Angularze proces ten odbywa siê poprzez oznaczenie klasy serwisu dekoratorem Injectable oraz zadeklarowanie odpowiedniej zale¿noœci w konstruktorze komponentu (serwis przekazuje siê jako argument konstruktora i przypisuje do odpowiedniego pola w klasie kompenentu). Przyk³ad wstrzykiwania zale¿noœci mo¿na zobaczyæ na listingu \ref{lst:DependencyInjection}, do kompenentu s¹ tam wstrzykiwane dwie zale¿noœci: TheoryApiService oraz ActivatedRoute. 

\begin{lstlisting}[caption={Wstrzykiwanie zale¿noœci do komponentu GuitarPageComponent}, label={lst:DependencyInjection}, language=JavaScript]
 constructor(api: TheoryApiService, route: ActivatedRoute) { 
    this.theoryApi = api;
    this.route = route;
  }
\end{lstlisting}


\subsection{Podstrony z wirtualnymi instrumentami}
Podstrony z wirtualnymi instrumentami zosta³y stworzone poprzez po³¹czenie ze sob¹ mniejszych komponentów: selektora zapytañ, suwaka reguluj¹cego g³oœnoœæ oraz wirtualnego instrumentu. \\
\begin{figure}[h]
\centering
\includegraphics[width=0.8\textwidth]{rys05/no_request_no_hover.png}
\caption{Widok strony z gitar¹ basow¹ przed wykonaniem zapytania}
\label{fig:noReqNoHov}
\end{figure}


W aplikacji zosta³y zaimplementowane dwa instrumenty: gitarê akustyczn¹ oraz gitarê basow¹. Bazuj¹ one na tym samym komponencie, poniewa¿ na poziomie abstrakcji, na którym operowano podczas implementacji róznica miêdzy nimi to tylko liczba strun.  \\

Na ka¿dym z instrumentów po wybraniu zapytania podœwietlaj¹ siê odpowiednie dŸwiêki. Wynik przyk³adowego zapytania mo¿na zobaczyæ na rysunkach \ref{fig:reqNoHov}, \ref{fig:reqHov} i \ref{fig:reqAcoustic}. Wybrano zapytanie o skalê F Natural Major (F-dur). W sk³ad tej skali wchodz¹ dŸwiêki: F,G,A,A\#,C,D,E i te dŸwiêki s¹ zaznaczone kolorem czerwonym. \\
Jeœli u¿ytkownika interesuj¹ tylko dŸwiêki nale¿¹ce do wybranego zapytania, mo¿e on wy³¹czyæ wyœwietlanie pozosta³ych dŸwiêków przyciskaj¹c guzik ``show notes on hover'' - powoduje on ukrycie wszystkich dŸwiêków, które nie nale¿¹ do aktualnego zapytania i wyœwietlanie ich dopiero po najechaniu kursorem. \\

Klikniêcie na dowolny dŸwiêk powoduje odtworzenie jego próbki dŸwiêkowej. Za odtwarzanie dŸwiêków odpowiada serwis AudioPlayerService. Klasa ta definiuje œcie¿ki do próbek dŸwiêkowych danego instrumentu oraz posiada metodê pozwalaj¹c¹ na odtworzenie dŸwiêku po stronie klienta. 
\begin{lstlisting}[caption={Metoda odtwrzaj¹ca zadany dŸwiêk}, label={lst:playNote}, language=JavaScript]
 playNote(guitar_string:string, note:string, volume:number)
  {
    let audio = new Audio();
    //change format, file path can't contain '#' symbol
    if(note.length > 1 && note[1] == '#')
      note = note[0] + 's' + note.substring(2);
    audio.src = this.samplesDirectory + guitar_string + "/" + note + ".wav";
    audio.volume = volume
    audio.load();
    audio.play();
  }
\end{lstlisting}

Nagrania próbowano pozyskaæ z serwisów oferuj¹cych darmowe próbki oraz gotowych paczek, jednak nie uda³o siê znaleŸæ pe³nego, darmowego zestawu, który mo¿na by³oby wykorzystaæ w ramach aplikacji, wiêc zdecydowano siê na w³asnorêczne nagranie gitar w domowych warunkach. \\

\begin{figure}[h]   
\centering
\includegraphics[width=0.8\textwidth]{rys05/request_no_hover.png}
\caption{Widok strony z gitar¹ basow¹ po wykonanu zapytania}
\label{fig:reqNoHov}
\end{figure}

\begin{figure}[h]
\centering
\includegraphics[width=0.8\textwidth]{rys05/request_hover.png}
\caption{Widok strony z gitar¹ basow¹ po wykonaniu zapytania i prze³¹czeniu opcji hover}
\label{fig:reqHov}
\end{figure}

\begin{figure}[h]
\centering
\includegraphics[width=0.8\textwidth]{rys05/request_acoustic.png}
\caption{Widok strony z gitar¹ akustyczn¹ po wykonaniu zapytania}
\label{fig:reqAcoustic}
\end{figure}



\subsection{Trening s³uchu}

Podstrona s³u¿¹ca do treningu ucha muzycznego to kolejny komponent wykorzystuj¹cy AudioService poprzez wstrzykiwanie zale¿noœci. \\ 
Æwiczenie polega na rozpoznawaniu odtwarzanego dŸwiêku ze s³uchu. U¿ytkownik mo¿e u¿yæ przycisku ``Play sound'' aby odtworzyæ próbkê. Guzik jest wieloktrotengo u¿ytku. Po ods³uchaniu próbki, u¿ytkownik wybiera jeden z dŸwiêków z listy rozwijanej i zatwierdza wybór guzikiem ``Check answer''. W wypadku udzielenia poprawnej odpowiedzi zwiêksza siê liczba punktów, a w wypadku z³ej, liczba punktów jest ustawiana na 0. W obu wypadkach losowany jest nowy dŸwiêk, aby u¿ytkownik móg³ kontynuowaæ æwiczenie. \\
Na stronie jest równie¿ guzik reset, który zeruje wynik u¿ytkownika oraz losuje now¹ próbkê dŸwiêkow¹.


\begin{figure}[h]
 \centering
 \includegraphics[width=0.8\textwidth]{rys05/ear_training1.png}
 \caption{Pocz¹tkowy stan komponentu treningu s³uchu}
\label{fig:ear1}
\end{figure}

\begin{figure}[h]
 \centering
 \includegraphics[width=0.8\textwidth]{rys05/ear_training2.png}
 \caption{Stan komponentu treningu s³uchu po udzieleniu poprawnej odpowiedzi}
\label{fig:ear2}
\end{figure}


\subsection{Quiz}

Ten komponent jest zale¿ny od serwisu TheoryApiService. Podstrona z quizem z wiedzy dotycz¹cej akordów dzia³a podobnie do podstrony z treningiem s³uchu - najpierw u¿ytkownikowi zadawane jest pytanie, póŸniej wybiera on odpowiedŸ za pomoc¹ list rozwijanych i zatwierdza wybór guzikiem.  Po udzieleniu dobrej odpowiedzi jego wynik jest inkrementowany, a po niepoprawnej wynik jest zerowany. W obu wypadkach po udzieleniu odpowiedzi losowane jest nowe pytanie. Na stronie jest równie¿ guzik reset losuj¹cy nowe pytanie i zeruj¹cy wynik. \\
Zaimplementowane pytania polegaj¹ na rozpoznawaniu losowo wybieranych akordów po buduj¹cych je dŸwiêkach, ³atwo jednak rozwin¹æ go dodatkowe pytania dodaj¹c do list np. interwa³y.

\begin{lstlisting}[caption={Metoda generuj¹ca losowy akord}, label={lst:rngChord}, language=JavaScript]
 getChord()
  {

    let chordName = this.chordsNames[Math.floor(Math.random() * this.chordsNames.length)];
    let noteName  = this.notes[Math.floor(Math.random() * this.notes.length)];
    this.currentChord = chordName;
    this.currentNote = noteName;
    this.notesInChord = null;
    
    if (noteName.includes('#') ){
      noteName = noteName[0] + 'S';
    }
    let split: number = chordName.indexOf(' ');
    chordName = chordName.toLowerCase();
    chordName = chordName.substr(0, split) + '_' + chordName.substr(split+1);
    console.log(noteName, chordName)
    this.theoryApi.getChord(noteName, chordName).subscribe(data => {
      this.notesInChord = data;
    });
    
  }
\end{lstlisting}


\begin{figure}[h]
 \centering
 \includegraphics[width=0.8\textwidth]{rys05/quiz1.png}
 \caption{Pocz¹tkowy stan komponentu treningu s³uchu}
\label{fig:quiz1}
\end{figure}

\begin{figure}[h]
 \centering
 \includegraphics[width=0.8\textwidth]{rys05/quiz2.png}
 \caption{Stan komponentu treningu s³uchu po udzieleniu poprawnej odpowiedzi}
\label{fig:quiz2}
\end{figure}

\section{Testowanie aplikacji}

\subsection{Lighthouse}

Wtyczka lighthouse pozwala na przetestowanie aplikacji webowych bior¹c pod uwagê charakterystyczne dla nich cechy, takie jak czas do za³adowania czy optymalizacja pod k¹tem wyszukiwania strony przez silniki wyszukiwania. 

\begin{figure}[H]
    \centering
    \includegraphics[width=0.7\textwidth]{rys05/lighthouse.png}
    \caption{Wyniki testu Lighthouse}
    \label{fig:lighthouse}
\end{figure}

Aplikacja przesz³a testy z dobrymi wynikami. Jednym ze znalezionych przez wtyczkê problemów okaza³a siê optymalizacja pod k¹tem silników wyszukiwania - w celu poprawy nale¿a³oby przede wszystkim zwiêkszyæ iloœæ metadanych opisuj¹cych stronê. \\
Kolejnym problemem jest wydajnoœæ aplikacji - tutaj informacja o wyniku <90 jest du¿o bardziej niepokoj¹ca, poniewa¿ wydajnoœæ bezpoœrednio wp³ywa na odczucia u¿ytkownika. W celu poprawienia wydajnoœci nale¿a³oby przede wszystkim przeanalizowaæ kod pod k¹tem funkcji, które mog¹ opóŸniaæ ³adowanie elementów strony. Nale¿y jednak pamiêtaæ, ¿e podczas testów zarówno frontend, backend jak i aplikacja testowa by³y uruchomione na tej samej maszynie, co mo¿e znacz¹co wp³ywaæ na wyniki testów wydajnoœciowych.
