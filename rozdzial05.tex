\chapter{Implementacja aplikacji} 

\section{Implementacja Backendu}
Schemat projektu aplikacji backendowej przedstawiono na rysunku \ref{fig:schemat_BE}. Najwa¿niejszymi modu³ami s¹ pliki \texttt{notes\_calc.py} i \texttt{theory\_api.py} -- odpowiadaj¹ one kolejno za obliczanie dŸwiêków w danych akordach, skalach czy interwa³ach oraz za tworzenie endpointów aplikacji. 
Pliki \texttt{chords.py}, \texttt{scales.py}, \texttt{intervals.py} to pliki pomocnicze zawieraj¹ce definicje wzorców wykorzystywanych przez \texttt{notes\_calc} oraz listy wszystkich dostêpnych obiektów. 
Pliki testów jednostkowych znajduj¹ siê w katalogu \texttt{tests.} 
\begin{figure}[h]
	 \centering
	 \includegraphics[width=0.35\textwidth]{rys05/schemat_BE.png}
	 \caption{Schemat projektu aplikacji frontendowej}
	 \label{fig:schemat_BE}
\end{figure}

\subsection{Endpointy}
Endpointy deklarowane s¹ w sposób typowy dla frameworka Flask, czyli poprzez dekoratory funkcji opisuj¹ce œcie¿kê oraz dostêpne metody. Wszystkie endpointy zawarte w API zwracaj¹ obiekty JSON. 
Elementy œcie¿ki zapisane jako \texttt{<name>} to parametry œcie¿ki -- zmienne, które s¹ póŸniej wykorzystywane w celu uszczegó³awiania zapytania. W g³ównym endpoincie API, przedstawionym na listingu \ref{lst:Endpoint}, œcie¿ka opisana jest trzema parametrami, z których ka¿dy coraz bardziej zawê¿a zapytanie. Pocz¹tkowo obszar poszukiwania odpowiedzi jest okreœlany przez \texttt{obj\_type} -- wybierana jest jedna 3 kategorii: skala, interwa³ lub akord. Nastêpnie podawana jest nuta g³ówna, a na koñcu nazwa obiektu. 

% TO DO: czy tutaj wciêcia s¹ poprawne? Zwykle s¹ to 4 spacje, a tutaj jest kilka tabulatorów!!!
% DONE: tabulotory s¹ ustawione na szerokoœæ 4 spacji, dla pewnoœci zmieni³em jeden z listingów kodu i efekt by³ taki sam
\begin{lstlisting}[caption={G³ówny endpoint stworzonego API}, label={lst:Endpoint}, language=Python, showstringspaces=false, basicstyle=\footnotesize\ttfamily]
@theory_api.route("/<obj_type>/<root>/<name>", methods=["GET"])
def get_obj(root: str, name: str, obj_type: str) -> flask.Response:
    # get root from link, check if it's a legal note and cast to proper format
    print(f"root:{root}; name:{name}; obj_type:{obj_type}")
    root = cast_root(root)
    if root is None:
        return wrong_request("Incorrect root note")

    # try to find proper object, if there's no matching obj type - wrong request
    obj = None
    if obj_type == "chord":
        obj = find_chord(root, name)
    elif obj_type == "scale":
        obj = find_scale(root, name)
    elif obj_type == "interval":
        obj = find_interval(root, name)
    else:
        return wrong_request("Incorrect obj_type in request")

    # obj type was correct, but interval wasn't found - wrong interval in request
    if obj is None:
        return wrong_request(f"Incorrect {obj_type} name")
        
    # all went smooth - return requested sound
    return jsonify(obj)
\end{lstlisting}


\subsection{Obliczanie dŸwiêków}
W celu obliczania dŸwiêków wykorzystano nastêpuj¹ce za³o¿enia:
\begin{itemize}
	 \item ka¿dy dŸwiêk ma wartoœæ liczbow¹ od 0 do 11, zaczynaj¹c od dŸwiêku 'E',
	 \item przez dŸwiêk rozumie siê równie¿ pó³tony,
	 \item oktawy to wielkoœci okresowe (po ostatnim dŸwiêku w oktawie nastêpuje powrót do pierwszego),
	 \item odleg³oœæ miêdzy pó³tonami wynosi 1 jednostkê.
\end{itemize}

Korzystaj¹c z takich za³o¿eñ wszystkie akordy, skale i interwa³y opisano za pomoc¹ odleg³oœci od poprzedniego dŸwiêku. Pierwszy dŸwiêk to zawsze nuta g³ówna, drugi dŸwiêk opisany jest odleg³oœci¹ od nuty g³ównej, trzeci dŸwiêk odleg³oœci¹ od drugiego dŸwiêku itd. Realizacja tych wzorców widoczna jest na listingu \ref{lst:chordsPatterns}.


\begin{lstlisting}[caption={Wzorce opisuj¹ce przyk³adowe akordy}, label={lst:chordsPatterns}, language=Python, showstringspaces=false, basicstyle=\footnotesize\ttfamily]
	 seventh_pattern = (4, 3, 3)
	 minor_seventh_pattern = (3, 4, 3)
	 major_seventh_pattern = (4, 3, 4)
	 diminished_seventh_pattern = (3, 3, 3)
\end{lstlisting}


Na podstawie opisanych za³o¿eñ oraz wzorców stworzono funkcje obliczaj¹ce dŸwiêki zawarte w skalach, akordach i interwa³ach na podstawie ich nazwy oraz nuty g³ównej. Na listingach \ref{lst:calcScale}, \ref{lst:calcChord} przedstawiono funkcje dla akordów oraz skal.

\begin{lstlisting}[caption={Funkcja obliczaj¹ca dŸwiêki w skali}, label={lst:calcScale}, language=Python, showstringspaces=false, basicstyle=\footnotesize\ttfamily]
def find_scale(root: str, scale_name: str) -> list:
    curr_sound = notes_mapping.get(root)
    pattern = scales_patterns.get(scale_name)
    if pattern is None:
        return None
    scale = [root]
    for step in pattern:
        curr_sound = step
        sound = sound_from_val(curr_sound % 12)
        scale.append(sound)
    return scale
\end{lstlisting}

\begin{lstlisting}[caption={Funkcja obliczaj¹ca dŸwiêki w akordzie}, label={lst:calcChord}, language=Python, showstringspaces=false, basicstyle=\footnotesize\ttfamily]
def find_chord(root: str, chord_name: str) -> list:
    curr_sound = notes_mapping.get(root)
    pattern = chords_patterns.get(chord_name)
    if pattern is None:
        return None
    chord = [root]
    for step in pattern:
        curr_sound = step
        sound = sound_from_val(curr_sound % 12)
        chord.append(sound)
    return chord
\end{lstlisting}

\section{Obserwacje i uwagi}
Po zaimplementowaniu ca³oœci aplikacji, zauwa¿ono, ¿e obliczenia s¹ na tyle niewymagaj¹ce, ¿e mog³yby byæ wykonywane po stronie frontendu zamiast dodatkowego API. Warto jednak zauwa¿yæ, ¿e API mo¿na ³atwo rozwin¹æ o dodatkowe funkcjonalnoœci, takie jak np. po³¹czenie z baz¹ danych, co mog³oby okazaæ siê przydatne w wypadku rozwoju aplikacji o konta u¿ytkowników. 

% TO DO: Proszê posklejaæ u¿ywaj¹c ~ wszystkie samotne literki na koñcach linii 
\section{Implementacja Frontendu}
Schemat projektu aplikacji frontendowej jest typowy dla aplikacji implementowanych w Angularze. Program podzielony jest na fragmenty zwane komponentami oraz serwisami. Ka¿dy komponent oraz ka¿dy serwis jest przechowywany w osobnym folderze. Szczegó³owy schemat projektu jest widoczny na rysunku \ref{fig:schemat_FE}a. Katalog \texttt{assests} zawiera zasoby wykorzystywane w~aplikacji, takie jak dŸwiêki czy obrazki. Oprócz komponentów stworzonych przez u¿ytkownika wykorzystywane s¹ równie¿ pliki wygenerowane za pomoc¹ Angular CLI znajduj¹ce siê w~katalogu g³ównym: 
	\begin{itemize}
	 \item \texttt{app-routing.module.ts} -- modu³ pozwalaj¹cy na zarz¹dzanie routingiem wewn¹trz projektu,
	 \item \texttt{app.module.ts} --  g³ówny modu³ aplikacji opisuj¹cy elementy importowane przez aplikacjê oraz deklarowane w niej komponenty i serwisy,
	 \item \texttt{app.*} -- pozosta³e pliki komponentu g³ównego,
	 \item \texttt{environment.prod.ts} -- plik zawieraj¹ce zmienne œrodowiskowe dla œrodowiska produkcyjnego,
	 \item \texttt{environment.ts} -- zmienne œrodowiskowe do wykorzystania podczas tworzenia i testowania aplikacji.
	\end{itemize}

\begin{figure}[h]
	 \centering
	\begin{tabular}{@{}ll@{}}
	a) & b) \\
  \vtop{\vskip-2ex\hbox{\includegraphics[width=0.40\linewidth]{rys05/schemat_FE.png}}} & 
	\vtop{\vskip-2ex\hbox{\includegraphics[width=0.36\linewidth]{rys05/schemat_FE2.png}}}
	\end{tabular}
  \caption{Schemat projektu aplikacji frontendowej: a) g³ówny folder, b) foldery \texttt{audio-player} oraz \texttt{guitar-page} zawieraj¹ce, odpowiednio, pliki serwisu i komponentu}
	\label{fig:schemat_FE}
\end{figure}

Ka¿dy komponent sk³ada siê z 4 plików:
\begin{itemize}
	 \item \texttt{component-name.css} -- plik opisuj¹cy style wykorzystane w obrêbie tego komponentu,
	 \item \texttt{component-name.html} -- plik opisuj¹cy rozk³ad elementów w danym komponencie. Angular pozwala na wykorzystywanie tam selektorów innych komponentów oraz dodatkowych dyrektyw, takich jak np.\ \texttt{ngIf} czy \texttt{ngFor},
	 \item \texttt{component-name.ts} -- plik zawieraj¹cy konstruktor komponentu oraz skrypty napisane przez u¿ytkownika dla danego komponentu,
	 \item \texttt{component-name.spec.ts} -- plik zawieraj¹cy testy jednostkowe komponentu.
\end{itemize}
Serwisy natomiast sk³adaj¹ siê domyœlnie z 2 plików: \texttt{service-name.ts} oraz \texttt{service-name.spec.ts}. Pe³ni¹ one takie same role jak w wypadku komponentów -- pierwszy z nich zawiera klasê serwisu, natomiast drugi jej testy jednostkowe. 
Zawartoœæ przyk³adowych katalogów z serwisem i komponentem mo¿na zobaczyæ na rysunku \ref{fig:schemat_FE}b.


\subsection{Strona g³ówna}
Na stronie g³ównej wyœwietlony jest panel z krótkim tekstem o aplikacji oraz jej autorze. 
Na górze strony widoczny jest pasek nawigacji, który pozwala na przejœcie do wszystkich funkcjonalnoœci aplikacji. 
To na tê stronê przekierowywany jest u¿ytkownik jeœli próbuje dostaæ siê na nieistniej¹c¹ podstronê. Widok strony g³ównej przedstawiono na rysunku \ref{fig:homepage}.
\begin{figure}[h]
	 \centering
	 \includegraphics[width=\textwidth]{rys05/homepage.png} % TO DO: powtórzony podpis pod rysunkiem, proszê poprawiæ
	 \caption{Strona g³ówna aplikacji wraz z widocznym paskiem nawigacji} % DONE: zmieniono podpis na poprawny
	 \label{fig:homepage}
\end{figure}


\subsection{Nawigacja}
% TO DO: przypominam o regu³ach stosowania czcionki maszynowej (nazwy plików, kod Ÿród³owy, nazwy klas itp.). Proszê poprawiæ.
% DONE: Poprawiono (mam nadziejê, ¿e wszêdzie)
Do nawigacji podczas korzystania z aplikacji s³u¿y pasek nawigacji umieszczony na górze strony. Ka¿dy z guzików jest odnoœnikiem do odpowiednich podstron. Próba przejœcia na podstrony, które nie s¹ wymienione na pasku nawigacji skutkuje przekierowaniem stronê g³ówn¹. Implementacja nawigacji opiera siê na wykorzystaniu modu³u \texttt{routing} zawartego w Angularze. W pliku \texttt{app-routing.module.ts} zdefiniowano wszystkie œcie¿ki obs³ugiwane przez aplikacjê. Mo¿na je zobaczyæ na listingu \ref{lst:routing}. Szczególnie warto zwróciæ uwagê na ostatni wpis w tablicy. Wpis \texttt{path: '**'} to tzw.\ dzika karta (ang.~\emph{wildcard route}) -- œcie¿ka, która jest wykorzystywana, kiedy u¿ytkownik próbuje dostaæ siê na dowoln¹ podstronê, która nie zosta³a opisana w tablicy przed wyst¹pieniem tego wpisu. Ze wzglêdu na sposób dzia³ania routingu, wa¿ne, aby dzika karta by³a na koñcu tablicy: podczas szukania œcie¿ki porównywana jest podana œcie¿ka i kolejne wartoœci pola \texttt{path} w tablicy \texttt{Routes}. Porównanie dowolnej œcie¿ki z symbolem \texttt{**} zawsze zwraca wartoœæ prawda, wiêc umieszczenie tego symbolu jako wczeœniejszego wpisu, zablokowa³oby dostêp do œcie¿ek zadeklarowanych póŸniej. 
\begin{lstlisting}[caption={Œcie¿ki zdefiniowane w aplikacji}, label={lst:routing}, language=JavaScript, showstringspaces=false, basicstyle=\footnotesize\ttfamily]
const routes: Routes = [
    {path: 'test', component: VirtualGuitarComponent, pathMatch: 'full'},
    {path: 'api', component: ApiRequestSelectorComponent, pathMatch: 'full'},
    {path: 'bass', component: GuitarPageComponent, pathMatch: 'full'},
    {path: 'acoustic', component: GuitarPageComponent, pathMatch: 'full'},
    {path: 'earTraining', component: EarTrainingComponent, pathMatch: 'full'},
    {path: 'practice', component: TheoryQuizComponent, pathMatch: 'full'},
    {path: '**', component: HomepageComponent}
];
\end{lstlisting}


\subsection{Komunikacja z API}
W celu komunikacji z API zaimplementowano serwis \texttt{TheoryApiService} oraz modele danych odpowiadaj¹ce tym z API, czyli klasy: \texttt{Chord}, \texttt{Interval} oraz \texttt{Scale} (patrz listing~\ref{lst:TheoryModel}). Serwis s³u¿y do wysy³ania zapytañ HTTP na zadany adres i rzutuje otrzymane dane na ¿¹dany typ. 

\begin{lstlisting}[caption={Klasa \texttt{Scale} wykorzystywana do zapytañ i przechowywania danych o skalach}, label={lst:TheoryModel}, language=JavaScript, showstringspaces=false, basicstyle=\footnotesize\ttfamily]
export class Scale {
    constructor(
        public name: string,
        public notes: string[],
    ) { }
}
\end{lstlisting}


\texttt{TheoryApiService} wykorzystuje zmienn¹ œrodowiskow¹ \texttt{API\_URL} pod któr¹ przechowywany jest adres API, dziêki czemu mo¿na modyfikowaæ adres API bez ingerencji w kod. Zastosowanie zmiennych œrodowiskowych jest szczególnie istotne kiedy dochodzi do dystrybucji aplikacji -- adresy API mog¹ siê zmieniaæ i nie powinno to powodowaæ potrzeby aktualizacji aplikacji. Przyk³adowe zapytanie do API z wykorzystaniem zmiennej œrodowiskowej mo¿na zobaczyæ na listingu \ref{lst:TheoryApiService}. 

\begin{lstlisting}[caption={Metoda klasy \texttt{TheoryApiService} wysy³aj¹ca zapytanie o dŸwiêki akordu do API}, label={lst:TheoryApiService}, language=JavaScript, showstringspaces=false, basicstyle=\footnotesize\ttfamily]
getChord(rootNote: string, name: string): Observable<Chord[]> {
    return this.http
    .get<Chord[]>(`${API_URL}/chord/${rootNote}/${name}`).pipe(
        tap(_ => console.log('fetched')),
        catchError(TheoryApiService._handleError)
    );
}
\end{lstlisting}





Takie rozwi¹zanie pozwala na wykorzystywanie tego samego serwisu w wielu komponentach poprzez wstrzykiwanie zale¿noœci. W Angularze proces ten odbywa siê poprzez oznaczenie klasy serwisu dekoratorem \texttt{Injectable} oraz zadeklarowanie odpowiedniej zale¿noœci w konstruktorze komponentu (serwis przekazuje siê jako argument konstruktora i przypisuje do odpowiedniego pola w klasie kompenentu). Przyk³ad wstrzykiwania zale¿noœci mo¿na zobaczyæ na listingu \ref{lst:DependencyInjection}, do komponentu s¹ tam wstrzykiwane dwie zale¿noœci: \texttt{TheoryApiService} oraz \texttt{ActivatedRoute}. 

\begin{lstlisting}[caption={Wstrzykiwanie zale¿noœci do komponentu \texttt{GuitarPageComponent}}, label={lst:DependencyInjection}, language=JavaScript, showstringspaces=false, basicstyle=\footnotesize\ttfamily]
	 constructor(api: TheoryApiService, route: ActivatedRoute) { 
			this.theoryApi = api;
			this.route = route;
		}
\end{lstlisting}


\subsection{Podstrony z wirtualnymi instrumentami}
Podstrony z wirtualnymi instrumentami stworzono poprzez po³¹czenie ze sob¹ mniejszych komponentów: selektora zapytañ, suwaka reguluj¹cego g³oœnoœæ oraz wirtualnego instrumentu. 

W aplikacji zaimplementowano dwa instrumenty: gitarê akustyczn¹ oraz gitarê basow¹ (patrz rysunek~\ref{fig:noReqNoHov}). Bazuj¹ one na tym samym komponencie, poniewa¿ na poziomie abstrakcji, na którym operowano podczas implementacji ró¿nica miêdzy nimi to tylko liczba strun.  
\begin{figure}[h]
	\centering
	\includegraphics[width=0.82\textwidth]{rys05/no_request_no_hover.png}
	\caption{Widok strony z gitar¹ basow¹ przed wykonaniem zapytania}
	\label{fig:noReqNoHov}
\end{figure}


Na ka¿dym z instrumentów po wybraniu zapytania podœwietlaj¹ siê odpowiednie dŸwiêki. Wynik przyk³adowego zapytania mo¿na zobaczyæ na rysunkach \ref{fig:reqNoHov}, \ref{fig:reqHov} i \ref{fig:reqAcoustic}. Wybrano zapytanie o skalê F Natural Major (F-dur). W sk³ad tej skali wchodz¹ dŸwiêki: F,G,A,A\#,C,D,E i te dŸwiêki s¹ zaznaczone kolorem czerwonym. 
\begin{figure}[h]   
	\centering
	\includegraphics[width=0.82\textwidth]{rys05/request_no_hover.png}
	\caption{Widok strony z gitar¹ basow¹ po wykonanu zapytania}
	\label{fig:reqNoHov}
\end{figure}
\begin{figure}[h]
	\centering
	\includegraphics[width=0.82\textwidth]{rys05/request_hover.png}
	\caption{Widok strony z gitar¹ basow¹ po wykonaniu zapytania i prze³¹czeniu opcji \texttt{hover}}
	\label{fig:reqHov}
\end{figure}
\begin{figure}[h]
	\centering
	\includegraphics[width=0.82\textwidth]{rys05/request_acoustic.png}
	\caption{Widok strony z gitar¹ akustyczn¹ po wykonaniu zapytania}
	\label{fig:reqAcoustic}
\end{figure}


Jeœli u¿ytkownika interesuj¹ tylko dŸwiêki nale¿¹ce do wybranego zapytania, mo¿e on wy³¹czyæ wyœwietlanie pozosta³ych dŸwiêków przyciskaj¹c guzik ``show notes on hover'' -- powoduje on ukrycie wszystkich dŸwiêków, które nie nale¿¹ do aktualnego zapytania i wyœwietlanie ich dopiero po najechaniu kursorem. 


Klikniêcie na dowolny dŸwiêk powoduje odtworzenie jego próbki dŸwiêkowej. Za odtwarzanie dŸwiêków odpowiada serwis \texttt{AudioPlayerService}. Klasa ta definiuje œcie¿ki do próbek dŸwiêkowych danego instrumentu oraz posiada metodê pozwalaj¹c¹ na odtworzenie dŸwiêku po stronie klienta (patrz listing~\ref{lst:playNote}).
\begin{lstlisting}[caption={Metoda odtwarzaj¹ca zadany dŸwiêk}, label={lst:playNote}, language=JavaScript, showstringspaces=false, basicstyle=\footnotesize\ttfamily]
playNote(guitar_string:string, note:string, volume:number)
{
    let audio = new Audio();
    //change format, file path can't contain '#' symbol
    if(note.length > 1 && note[1] == '#')
        note = note[0] + 's' + note.substring(2);
    audio.src = this.samplesDirectory + guitar_string + "/" + note + ".wav";
    audio.volume = volume
    audio.load();
    audio.play();
}
	\end{lstlisting}

Nagrania próbowano pozyskaæ z serwisów oferuj¹cych darmowe próbki oraz gotowych paczek, jednak nie uda³o siê znaleŸæ pe³nego, darmowego zestawu, który mo¿na by³oby wykorzystaæ w ramach aplikacji, wiêc zdecydowano siê na w³asnorêczne nagranie gitar w domowych warunkach. 




\subsection{Trening s³uchu}
Podstrona s³u¿¹ca do treningu ucha muzycznego to kolejny komponent wykorzystuj¹cy \texttt{AudioService} poprzez wstrzykiwanie zale¿noœci. 
 
Æwiczenie polega na rozpoznawaniu odtwarzanego dŸwiêku ze s³uchu. U¿ytkownik mo¿e u¿yæ przycisku ``Play sound'' aby odtworzyæ próbkê. Guzik jest wielokrotnego u¿ytku. Po ods³uchaniu próbki, u¿ytkownik wybiera jeden z dŸwiêków z listy rozwijanej i zatwierdza wybór guzikiem ``Check answer''. W wypadku udzielenia poprawnej odpowiedzi zwiêksza siê liczba punktów, a w wypadku z³ej, liczba punktów jest ustawiana na 0. W obu wypadkach losowany jest nowy dŸwiêk, aby u¿ytkownik móg³ kontynuowaæ æwiczenie. 

Na stronie jest równie¿ guzik reset, który zeruje wynik u¿ytkownika oraz losuje now¹ próbkê dŸwiêkow¹. Opisany komponent przedstawiono na rysunku \ref{fig:earTraining}.
% TO DO: brak referencji w teœkcie do rysunków. Proszê uzupe³niæ !!!
% DONE: dodano referencjê
\begin{figure}[htb]
  \centering
	\begin{tabular}{@{}ll@{}}
	a) & b) \\
  \vtop{\vskip-2ex\hbox{\includegraphics[width=0.48\linewidth]{rys05/ear_training1}}} & 
	\vtop{\vskip-2ex\hbox{\includegraphics[width=0.48\linewidth]{rys05/ear_training2}}}
	\end{tabular}
  \caption{Stan komponentu \texttt{EarTraining}: a) po za³adowaniu, b) po udzieleniu dobrej odpowiedzi}
  \label{fig:earTraining}
\end{figure}




\subsection{Quiz}
Ten komponent jest zale¿ny od serwisu \texttt{TheoryApiService}. Podstrona z quizem z wiedzy dotycz¹cej akordów dzia³a podobnie do podstrony z treningiem s³uchu -- najpierw u¿ytkownikowi zadawane jest pytanie, póŸniej wybiera on odpowiedŸ za pomoc¹ list rozwijanych i zatwierdza wybór guzikiem.  Po udzieleniu dobrej odpowiedzi jego wynik jest inkrementowany, a po niepoprawnej wynik jest zerowany. W obu wypadkach po udzieleniu odpowiedzi losowane jest nowe pytanie. Na stronie jest równie¿ guzik reset losuj¹cy nowe pytanie i zeruj¹cy wynik. Widok quizu mo¿na zobaczyæ na rysunku \ref{fig:quiz}. 
\begin{figure}[htb]
  \centering
	\begin{tabular}{@{}ll@{}}
	a) & b) \\
  \vtop{\vskip-2ex\hbox{\includegraphics[width=0.46\linewidth]{rys05/quiz1}}} & 
	\vtop{\vskip-2ex\hbox{\includegraphics[width=0.46\linewidth]{rys05/quiz2}}}
	\end{tabular}
  \caption{Stan komponentu z quizem teoretycznym: a) po za³adowaniu, b) po udzieleniu dobrej odpowiedzi}
  \label{fig:quiz}
\end{figure}


Zaimplementowane pytania polegaj¹ na rozpoznawaniu losowo wybieranych akordów po buduj¹cych je dŸwiêkach, ³atwo jednak rozwin¹æ go dodatkowe pytania dodaj¹c do list np. interwa³y. Kod odpowiadaj¹cy za losowy wybór akordów przedstawiono na listingu \ref{lst:rngChord}.

\begin{lstlisting}[caption={Metoda generuj¹ca losowy akord}, label={lst:rngChord}, language=JavaScript, showstringspaces=false, basicstyle=\footnotesize\ttfamily]
getChord()
{
    let chordName = this.chordsNames[Math.floor(Math.random() * this.chordsNames.length)];
    let noteName  = this.notes[Math.floor(Math.random() * this.notes.length)];
    this.currentChord = chordName;
    this.currentNote = noteName;
    this.notesInChord = null;
    // change '#' to 'S' so it can be send to API ('#' is a problematic char).
    if (noteName.includes('#') ){
        noteName = noteName[0] + 'S';
    }
    let split: number = chordName.indexOf(' ');
    chordName = chordName.toLowerCase();
    chordName = chordName.substr(0, split) + '_' + chordName.substr(split+1);
    this.theoryApi.getChord(noteName, chordName).subscribe(data => {
        this.notesInChord = data;
    });	
}
\end{lstlisting}



\section{Testowanie aplikacji}

\subsection{Lighthouse}
Wtyczka lighthouse pozwala na przetestowanie aplikacji webowych bior¹c pod uwagê charakterystyczne dla nich cechy, takie jak czas do za³adowania czy optymalizacja pod k¹tem wyszukiwania strony przez silniki wyszukiwania. Wyniki testowania aplikacji za pomoc¹ tej wtyczki s¹ widoczne na rysunku \ref{fig:lighthouse}. 
\begin{figure}[h]
			\centering
			\includegraphics[width=0.4\textwidth]{rys05/lighthouse.png}
			\caption{Wyniki testu Lighthouse}
			\label{fig:lighthouse}
\end{figure}

Aplikacja przesz³a testy z dobrymi wynikami. Jednym ze znalezionych przez wtyczkê problemów okaza³a siê optymalizacja pod k¹tem silników wyszukiwania -- w celu poprawy nale¿a³oby przede wszystkim zwiêkszyæ iloœæ metadanych opisuj¹cych stronê. 

Kolejnym problemem jest wydajnoœæ aplikacji -- tutaj informacja o wyniku <90 jest du¿o bardziej niepokoj¹ca, poniewa¿ wydajnoœæ bezpoœrednio wp³ywa na odczucia u¿ytkownika. W celu poprawienia wydajnoœci nale¿a³oby przede wszystkim przeanalizowaæ kod pod k¹tem funkcji, które mog¹ opóŸniaæ ³adowanie elementów strony. Nale¿y jednak pamiêtaæ, ¿e podczas testów zarówno frontend, backend jak i aplikacja testowa by³y uruchomione na tej samej maszynie, co mo¿e znacz¹co wp³ywaæ na wyniki testów wydajnoœciowych.
